from datetime import datetime, timezone
from typing import List, Optional

from core.tools.code_execution_tool import exec_read_csv, exec_write_csv
from core.agents.types import Email, TriageResult, KBContext, ReplyResult


class ReplyAgent:
    """
    ReplyAgent

    Responsibilities:
    - Take: Email + TriageResult + KBContext (+ optional thread_emails).
    - Draft a reply (subject + body) using simple templates + KB hints.
    - Recommend follow-up actions (e.g. suggest creating a ticket).
    - Update inbox.csv metadata (last_action, last_action_datetime_utc, notes).

    Interface:
    - __init__()
    - run(
        email: Email,
        triage: TriageResult,
        kb_context: KBContext,
        thread_emails: Optional[List[Email]] = None
      ) -> ReplyResult
    """

    def __init__(self):
        pass

    def run(
        self,
        email: Email,
        triage: TriageResult,
        kb_context: KBContext,
        thread_emails: Optional[List[Email]] = None,
    ) -> ReplyResult:
        reply_subject = self._build_subject(email, triage, thread_emails)
        reply_body = self._build_body(email, triage, kb_context, thread_emails)
        follow_up_action = self._build_follow_up_action(email, triage, kb_context)

        # Update inbox.csv metadata
        self._update_inbox_metadata(
            email_id=email.email_id,
            reply_summary=reply_body[:250],
        )

        return ReplyResult(
            email_id=email.email_id,
            reply_subject=reply_subject,
            reply_body=reply_body,
            follow_up_action=follow_up_action,
            notes="Draft reply generated by ReplyAgent",
        )

    # ---------- SUBJECT ----------
    def _build_subject(
        self,
        email: Email,
        triage: TriageResult,
        thread_emails: Optional[List[Email]] = None,
    ) -> str:
        # If already a reply or part of a longer thread, keep subject as is
        if email.subject.lower().startswith("re:"):
            return email.subject

        if thread_emails and len(thread_emails) > 1:
            # Already part of a thread, so keep subject stable
            return email.subject

        return f"Re: {email.subject}"

    # ---------- BODY ----------
    def _build_body(
        self,
        email: Email,
        triage: TriageResult,
        kb_context: KBContext,
        thread_emails: Optional[List[Email]] = None,
    ) -> str:
        greeting_name = email.from_name or "there"

        # Follow-up vs first contact tone
        is_follow_up_thread = thread_emails is not None and len(thread_emails) > 1
        if is_follow_up_thread:
            thanks_line = "Thanks for following up about this!"
        else:
            thanks_line = "Thank you for reaching out and thinking of us for this campaign!"

        # Try to find any obviously relevant KB snippet to mention (title only for now)
        kb_titles = [hit.get("title") for hit in kb_context.kb_entries if hit.get("title")]
        kb_line = ""
        if kb_titles:
            kb_line = f" (based on our internal guidelines: {kb_titles[0]})"

        cat = triage.category or "Other / Uncategorized"

        if cat.startswith("Brand/Sponsorship"):
            body = f"""Hi {greeting_name},

{thanks_line}{kb_line}

We'd love to learn more about the product, timeline, deliverables, and budget for this collaboration. 
Please share:
- Your ideal posting dates
- Required deliverables (e.g. 1x sponsored video, stories, usage rights)
- Proposed budget and any specific guidelines

Looking forward to hearing from you.

Best,
Creator Team
"""
        elif cat == "Creator Collaboration":
            opener = (
                "Thanks for reaching out about a collaboration!"
                if not is_follow_up_thread
                else "Thanks for continuing the conversation about this collaboration!"
            )
            body = f"""Hi {greeting_name},

{opener}{kb_line}

Your idea sounds interesting. Could you please share:
- The concept you have in mind
- Platforms you’d like to collaborate on
- Any timelines or deadlines
- Whether this is a paid or organic collaboration

Once we have those details, we can see if it’s a good fit.

Best,
Creator Team
"""
        elif cat == "PR / Media / Interviews":
            opener = (
                "Thank you for the media / interview request!"
                if not is_follow_up_thread
                else "Thanks for following up about the interview details!"
            )
            body = f"""Hi {greeting_name},

{opener}{kb_line}

This sounds exciting. Please share:
- The outlet and format (article, podcast, video, etc.)
- Estimated recording / publishing dates
- Topics or sample questions
- Any specific requirements or talking points

We’ll review and confirm availability.

Best,
Creator Team
"""
        elif cat == "Platform / Account Notifications":
            body = f"""Hi {greeting_name},

Thanks for the update regarding the account.{kb_line}

We’ve reviewed the notification and will follow the recommended steps on our side. 
If there are any actions you need from us directly, please confirm the details in reply to this email.

Best,
Creator Team
"""
        elif cat == "Customer Support (for creators selling products)":
            body = f"""Hi {greeting_name},

Thanks for reaching out!{kb_line}

We’re sorry for any inconvenience. Please share your order number and any screenshots or additional details, 
and we’ll look into this as soon as possible.

Best,
Creator Support
"""
        elif cat == "Spam / Phishing / Irrelevant":
            body = f"""Hi {greeting_name},

Thank you for your message.

At this time, this opportunity is not a fit, so we’ll have to pass. 

Best,
Creator Team
"""
        else:
            body = f"""Hi {greeting_name},

Thank you for reaching out!{kb_line}

We’ve received your message and will review the details. If we have any follow-up questions or next steps,
we’ll get back to you soon.

Best,
Creator Team
"""

        return body

    # ---------- FOLLOW-UP ACTION ----------
    def _build_follow_up_action(self, email: Email, triage: TriageResult, kb_context: KBContext):
        """
        Convert the triage ticket suggestion into a follow_up_action payload
        that the Orchestrator can later pass into ticket_logger_tool.
        """
        if not triage.ticket_suggestion:
            return None

        suggestion = triage.ticket_suggestion

        return {
            "create_ticket": True,
            "ticket_payload": {
                "creator_id": email.creator_id,
                "email_id": email.email_id,
                "type": suggestion.get("type", "Follow-up"),
                "title": f"Follow-up: {triage.category}",
                "description": suggestion.get("reason", "Follow-up suggested by triage agent."),
                "priority": suggestion.get("suggested_priority", triage.priority or "P2"),
            },
        }

    # ---------- INBOX METADATA UPDATE ----------
    def _update_inbox_metadata(self, email_id: int, reply_summary: str) -> None:
        df = exec_read_csv("inbox.csv")

        if "email_id" not in df.columns:
            raise ValueError("inbox.csv is missing 'email_id' column.")

        mask = df["email_id"] == email_id
        if not mask.any():
            raise ValueError(f"No inbox row found for email_id={email_id}")

        now_utc = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

        if "last_action" in df.columns:
            df.loc[mask, "last_action"] = "draft_reply"
        if "last_action_datetime_utc" in df.columns:
            df.loc[mask, "last_action_datetime_utc"] = now_utc
        if "notes" in df.columns:
            df.loc[mask, "notes"] = reply_summary

        exec_write_csv(df, "inbox.csv")
